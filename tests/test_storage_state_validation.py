#!/usr/bin/env python3
"""
Storage State Management Validation Tests
==========================================

Validates storage state loading, Netscape conversion, and cookie sanitization
functionality as specified in Requirements 1, 11, 12, and 13.
"""

import os
import sys
import unittest
import tempfile
import json
import shutil
from pathlib import Path
from unittest.mock import Mock, patch

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

class TestStorageStateValidation(unittest.TestCase):
    """Test storage state loading and validation"""
    
    def setUp(self):
        """Set up test environment"""
        self.temp_dir = tempfile.mkdtemp()
        self.cookie_dir = Path(self.temp_dir)
        self.storage_state_path = self.cookie_dir / "youtube_session.json"
        
    def tearDown(self):
        """Clean up test environment"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_valid_storage_state_structure(self):
        """Test that storage state has required structure"""
        # Create valid storage state
        storage_state = {
            "cookies": [
                {
                    "name": "CONSENT",
                    "value": "YES+cb.20210328-17-p0.en+FX+123",
                    "domain": ".youtube.com",
                    "path": "/",
                    "expires": 1735689600,
                    "httpOnly": False,
                    "secure": True,
                    "sameSite": "None"
                }
            ],
            "origins": [
                {
                    "origin": "https://www.youtube.com",
                    "localStorage": []
                }
            ]
        }
        
        with open(self.storage_state_path, 'w') as f:
            json.dump(storage_state, f)
        
        # Validate structure
        with open(self.storage_state_path, 'r') as f:
            loaded_state = json.load(f)
        
        self.assertIn('cookies', loaded_state)
        self.assertIn('origins', loaded_state)
        self.assertIsInstance(loaded_state['cookies'], list)
        self.assertIsInstance(loaded_state['origins'], list)
    
    def test_storage_state_cookie_validation(self):
        """Test that cookies in storage state have required fields"""
        storage_state = {
            "cookies": [
                {
                    "name": "test_cookie",
                    "value": "test_value",
                    "domain": ".youtube.com",
                    "path": "/",
                    "expires": 1735689600,
                    "httpOnly": False,
                    "secure": True,
                    "sameSite": "None"
                }
            ],
            "origins": []
        }
        
        with open(self.storage_state_path, 'w') as f:
            json.dump(storage_state, f)
        
        with open(self.storage_state_path, 'r') as f:
            loaded_state = json.load(f)
        
        cookie = loaded_state['cookies'][0]
        required_fields = ['name', 'value', 'domain', 'path', 'expires', 'httpOnly', 'secure', 'sameSite']
        
        for field in required_fields:
            self.assertIn(field, cookie, f"Cookie missing required field: {field}")


class TestNetscapeConversion(unittest.TestCase):
    """Test Netscape to storage state conversion"""
    
    def setUp(self):
        """Set up test environment"""
        self.temp_dir = tempfile.mkdtemp()
        self.cookie_dir = Path(self.temp_dir)
        
    def tearDown(self):
        """Clean up test environment"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_netscape_parsing(self):
        """Test parsing of Netscape cookie format"""
        netscape_content = """# Netscape HTTP Cookie File
# Generated by wget, do not edit.
.youtube.com	TRUE	/	FALSE	1735689600	CONSENT	YES+cb.20210328-17-p0.en+FX+123
.youtube.com	TRUE	/	TRUE	1735689600	session_token	abc123def456
www.youtube.com	FALSE	/watch	FALSE	1735689600	watch_token	xyz789
"""
        
        netscape_path = self.cookie_dir / "cookies.txt"
        with open(netscape_path, 'w') as f:
            f.write(netscape_content)
        
        try:
            from cookie_generator import parse_netscape_cookies
            
            cookies = parse_netscape_cookies(str(netscape_path))
            
            # Should parse 3 cookies
            self.assertEqual(len(cookies), 3)
            
            # Check first cookie
            consent_cookie = next((c for c in cookies if c['name'] == 'CONSENT'), None)
            self.assertIsNotNone(consent_cookie)
            self.assertEqual(consent_cookie['domain'], '.youtube.com')
            self.assertEqual(consent_cookie['path'], '/')
            self.assertFalse(consent_cookie['secure'])  # FALSE in Netscape format
            
            # Check secure cookie
            session_cookie = next((c for c in cookies if c['name'] == 'session_token'), None)
            self.assertIsNotNone(session_cookie)
            self.assertTrue(session_cookie['secure'])  # TRUE in Netscape format
            
        except ImportError as e:
            self.skipTest(f"Cookie generator not available: {e}")
    
    def test_netscape_to_storage_state_conversion(self):
        """Test complete conversion from Netscape to storage state"""
        netscape_content = """# Netscape HTTP Cookie File
.youtube.com	TRUE	/	FALSE	1735689600	CONSENT	YES+cb.20210328-17-p0.en+FX+123
.youtube.com	TRUE	/	TRUE	1735689600	session_token	abc123def456
"""
        
        netscape_path = self.cookie_dir / "cookies.txt"
        with open(netscape_path, 'w') as f:
            f.write(netscape_content)
        
        try:
            from cookie_generator import convert_netscape_to_storage_state
            
            # Set COOKIE_DIR for conversion
            with patch.dict(os.environ, {'COOKIE_DIR': str(self.cookie_dir)}):
                result_path = convert_netscape_to_storage_state(str(netscape_path))
            
            # Verify storage state was created
            self.assertTrue(Path(result_path).exists())
            
            # Verify content
            with open(result_path, 'r') as f:
                storage_state = json.load(f)
            
            # Check structure
            self.assertIn('cookies', storage_state)
            self.assertIn('origins', storage_state)
            
            # Check cookies were converted
            cookies = storage_state['cookies']
            self.assertEqual(len(cookies), 2)
            
            # Verify cookie properties
            consent_cookie = next((c for c in cookies if c['name'] == 'CONSENT'), None)
            self.assertIsNotNone(consent_cookie)
            self.assertEqual(consent_cookie['domain'], '.youtube.com')
            
        except ImportError as e:
            self.skipTest(f"Cookie generator not available: {e}")


class TestHostCookieSanitization(unittest.TestCase):
    """Test __Host- cookie sanitization"""
    
    def test_host_cookie_normalization(self):
        """Test __Host- cookie normalization"""
        try:
            from cookie_generator import sanitize_host_cookies
            
            cookies = [
                {
                    'name': '__Host-session',
                    'value': 'abc123',
                    'domain': '.youtube.com',
                    'path': '/watch',
                    'secure': False,
                    'httpOnly': True
                },
                {
                    'name': '__Host-csrf',
                    'value': 'def456',
                    'domain': 'youtube.com',
                    'path': '/api',
                    'secure': True,
                    'httpOnly': False
                },
                {
                    'name': 'regular_cookie',
                    'value': 'ghi789',
                    'domain': '.youtube.com',
                    'path': '/',
                    'secure': True,
                    'httpOnly': False
                }
            ]
            
            sanitized = sanitize_host_cookies(cookies)
            
            # Find __Host- cookies
            host_session = next((c for c in sanitized if c['name'] == '__Host-session'), None)
            host_csrf = next((c for c in sanitized if c['name'] == '__Host-csrf'), None)
            regular = next((c for c in sanitized if c['name'] == 'regular_cookie'), None)
            
            # Verify __Host- cookie sanitization
            self.assertIsNotNone(host_session)
            self.assertTrue(host_session['secure'])  # Should be secure=True
            self.assertEqual(host_session['path'], '/')  # Should be path="/"
            self.assertNotIn('domain', host_session)  # Domain should be removed
            
            self.assertIsNotNone(host_csrf)
            self.assertTrue(host_csrf['secure'])
            self.assertEqual(host_csrf['path'], '/')
            self.assertNotIn('domain', host_csrf)
            
            # Regular cookie should be unchanged
            self.assertIsNotNone(regular)
            self.assertEqual(regular['domain'], '.youtube.com')
            self.assertEqual(regular['path'], '/')
            
        except ImportError as e:
            self.skipTest(f"Cookie sanitization not available: {e}")
    
    def test_host_cookie_url_field(self):
        """Test that __Host- cookies use url field instead of domain"""
        try:
            from cookie_generator import sanitize_host_cookies
            
            cookies = [
                {
                    'name': '__Host-test',
                    'value': 'test123',
                    'domain': '.youtube.com',
                    'path': '/test',
                    'secure': False
                }
            ]
            
            sanitized = sanitize_host_cookies(cookies)
            host_cookie = sanitized[0]
            
            # Should not have domain field
            self.assertNotIn('domain', host_cookie)
            
            # Should have url field for Playwright compatibility
            self.assertIn('url', host_cookie)
            self.assertIn('youtube.com', host_cookie['url'])
            
        except ImportError as e:
            self.skipTest(f"Cookie sanitization not available: {e}")


class TestConsentCookieInjection(unittest.TestCase):
    """Test SOCS/CONSENT cookie injection"""
    
    def test_missing_consent_cookie_injection(self):
        """Test injection when no consent cookies are present"""
        try:
            from cookie_generator import inject_consent_cookies_if_missing
            
            storage_state = {
                'cookies': [
                    {
                        'name': 'session_token',
                        'value': 'abc123',
                        'domain': '.youtube.com',
                        'path': '/',
                        'secure': True
                    }
                ],
                'origins': []
            }
            
            updated_state = inject_consent_cookies_if_missing(storage_state)
            
            # Should have added consent cookie
            cookie_names = [cookie['name'] for cookie in updated_state['cookies']]
            has_consent = any(name in ['SOCS', 'CONSENT'] for name in cookie_names)
            self.assertTrue(has_consent)
            
            # Find consent cookie
            consent_cookie = next((c for c in updated_state['cookies'] if c['name'] in ['SOCS', 'CONSENT']), None)
            self.assertIsNotNone(consent_cookie)
            
            # Verify properties
            self.assertEqual(consent_cookie['domain'], '.youtube.com')
            self.assertEqual(consent_cookie['path'], '/')
            self.assertGreater(consent_cookie['expires'], 1735689600)  # Should have long expiry
            
        except ImportError as e:
            self.skipTest(f"Consent cookie injection not available: {e}")
    
    def test_existing_consent_cookie_preserved(self):
        """Test that existing consent cookies are not modified"""
        try:
            from cookie_generator import inject_consent_cookies_if_missing
            
            storage_state = {
                'cookies': [
                    {
                        'name': 'CONSENT',
                        'value': 'YES+cb.existing',
                        'domain': '.youtube.com',
                        'path': '/',
                        'secure': True,
                        'expires': 1735689600
                    }
                ],
                'origins': []
            }
            
            original_cookie_count = len(storage_state['cookies'])
            updated_state = inject_consent_cookies_if_missing(storage_state)
            
            # Should not add another consent cookie
            self.assertEqual(len(updated_state['cookies']), original_cookie_count)
            
            # Original consent cookie should be preserved
            consent_cookie = next((c for c in updated_state['cookies'] if c['name'] == 'CONSENT'), None)
            self.assertIsNotNone(consent_cookie)
            self.assertEqual(consent_cookie['value'], 'YES+cb.existing')
            
        except ImportError as e:
            self.skipTest(f"Consent cookie injection not available: {e}")
    
    def test_socs_cookie_recognition(self):
        """Test that SOCS cookies are recognized as consent cookies"""
        try:
            from cookie_generator import inject_consent_cookies_if_missing
            
            storage_state = {
                'cookies': [
                    {
                        'name': 'SOCS',
                        'value': 'CAI',
                        'domain': '.youtube.com',
                        'path': '/',
                        'secure': True,
                        'expires': 1735689600
                    }
                ],
                'origins': []
            }
            
            original_cookie_count = len(storage_state['cookies'])
            updated_state = inject_consent_cookies_if_missing(storage_state)
            
            # Should not add another consent cookie since SOCS is present
            self.assertEqual(len(updated_state['cookies']), original_cookie_count)
            
        except ImportError as e:
            self.skipTest(f"Consent cookie injection not available: {e}")


def main():
    """Run storage state validation tests"""
    print("Storage State Management Validation Tests")
    print("=" * 60)
    
    # Run tests
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    test_classes = [
        TestStorageStateValidation,
        TestNetscapeConversion,
        TestHostCookieSanitization,
        TestConsentCookieInjection
    ]
    
    for test_class in test_classes:
        tests = loader.loadTestsFromTestCase(test_class)
        suite.addTests(tests)
    
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Summary
    print("\n" + "=" * 60)
    if result.wasSuccessful():
        print("All storage state validation tests passed!")
        print("\nValidated:")
        print("   - Storage state structure and validation")
        print("   - Netscape cookie parsing and conversion")
        print("   - __Host- cookie sanitization")
        print("   - SOCS/CONSENT cookie injection")
        return 0
    else:
        print(f"Tests failed: {len(result.failures)} failures, {len(result.errors)} errors")
        return 1


if __name__ == "__main__":
    sys.exit(main())